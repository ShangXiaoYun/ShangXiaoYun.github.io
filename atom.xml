<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://shangxiaoyun.github.io</id>
    <title>晓云的个人博客</title>
    <updated>2022-08-11T19:08:51.338Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://shangxiaoyun.github.io"/>
    <link rel="self" href="https://shangxiaoyun.github.io/atom.xml"/>
    <subtitle>一点记录</subtitle>
    <logo>https://shangxiaoyun.github.io/images/avatar.png</logo>
    <icon>https://shangxiaoyun.github.io/favicon.ico</icon>
    <rights>All rights reserved 2022, 晓云的个人博客</rights>
    <entry>
        <title type="html"><![CDATA[Cesium 数据组织优化]]></title>
        <id>https://shangxiaoyun.github.io/post/cesium-shu-ju-zu-zhi-you-hua/</id>
        <link href="https://shangxiaoyun.github.io/post/cesium-shu-ju-zu-zhi-you-hua/">
        </link>
        <updated>2022-08-11T18:38:14.000Z</updated>
        <content type="html"><![CDATA[<p>上一篇作为一个初学者总结了一些渲染优化的技术和一点想法。这一篇与我的研究方向相关。由于集中做实验还没有整理发论文和专利，因此只简单分析一下存在的问题，展示一下改进后的效果。尘埃落定后会公开方法和代码到 github 上。</p>
<p>实验中主要涉及两个比较大的数据（不含调研、分析的数据集），一份是全长沙的数据，来自教研室，由于买的已经是最终的b3dm数据，因此只能在索引文件上做文章。第二份香港数据来自公开数据集，2017年3月及2018年3月由香港规划署制作，覆盖香港岛和九龙半岛部分（超过500G）。链接我会附在文末。这里要注意了，一定不要直接下b3dm 数据集，无论在 Cesium 还是 UE 上都不能正常显示，Cesium 直接加载不出来，UE 上模型没有纹理。排除 gltf 版本问题，Cesium 上改过无效。正解是下载 osgb格式，然后再转化成b3dm格式，涉及到两个工具。由于两块数据格式不同，其中一块组合成一个tileset，可以使用CesiumLab处理，还有一块每个tile作为一个 tileset，总共有超过1000个tileset，那这时候就去github 上找b3dm-tool工具，配置后再处理。具体方法另外分享，也踩了不少坑。确实很难理解为什么要这么生产数据，平白多了那么多步骤。</p>
<p>数据组织优化这一块需要了解 3dtiles 规范，对多种数据格式进行分析。此外还需要了解 LOD 金字塔格式。后面会一一填坑。</p>
<p>针对多批次数据同时加载速度缓慢的问题，将单颗瓦片树的单层网格索引重构为四叉树索引，提升加载效率，将遍历并选择待请求瓦片阶段的速率提升 28.36%。</p>
<p>效果视频如下（上述测试是分开测试，取多次实验结果，此处是一起开，仅看先后状态，不纠结具体数值提升）：https://www.bilibili.com/video/bv1hg411k7wP?vd_source=1abeefe13381c97e3a10c86d239b6aa4</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Cesium 渲染优化方法]]></title>
        <id>https://shangxiaoyun.github.io/post/cesium-xuan-ran-you-hua-fang-fa/</id>
        <link href="https://shangxiaoyun.github.io/post/cesium-xuan-ran-you-hua-fang-fa/">
        </link>
        <updated>2022-08-11T18:07:45.000Z</updated>
        <content type="html"><![CDATA[<p>基于 Cesium 的三维倾斜摄影模型可视化的优化可以从两大方面进行：数据组织调度优化和渲染优化。结合论文和相关博客并结合，在渲染优化方面，针对性能瓶颈：（1）CPU：过多的 Draw Calls （渲染命令）传给GPU意味着每次都要重新准备顶点数据、重新设置 shader，耗时耗力；（2）顶点处理：过多的顶点；（3）像素(Fragment)处理：过多的像素，对屏幕上的像素绘制多次(overdraws)；（4）带宽：尺寸很大且未压缩的纹理，分辨率过高的frameBuffer。</p>
<p>那与之相对的优化技术如下：（1）CPU：减少 Draw Calls （方法：批处理）（2）顶点优化：优化几何体，在Cesium中采用的是 LOD (Level of Detail) 技术和遮挡剔除(Occlusion culling)技术。（3）像素优化方面，Cesium 中采用了控制绘制顺序，用pass 通道定制了9 个优先级，透明物体在非透明物体后绘制，排第8 级，覆盖物体排第 9 级。除了控制绘制顺序，还可以减少实时光照来达到优化的目的。（4）带宽优化：减少纹理大小（纹理压缩）等。</p>
<p>以上参考了Unity 的优化技术，在 Cesium 中或多或少有所体现。针对批处理，3dtiles 规范支持 i3dm 格式的模型，它就是解决种类少、个数多的模型进行高效组织，例如路灯、电塔、井盖、垃圾桶等城市管理的附属物。相当于用同一个模型放置在画面的不同位置（通过matrix转换），但只调用一次DrawCall。i3dm 格式针对静态物体。针对动目标，比如航行的飞机。Cesium 中的未公开函数<strong><strong>ModelInstanceCollection()</strong></strong> 可以实现。</p>
<p>根据沙盒的示例做实验，10000架飞机实例化与10000架飞机逐个绘制对比，对比结果如下图。</p>
<figure data-type="image" tabindex="1"><img src="https://shangxiaoyun.github.io/post-images/1660241302166.png" alt="" loading="lazy"></figure>
<figure data-type="image" tabindex="2"><img src="https://shangxiaoyun.github.io/post-images/1660241310476.png" alt="" loading="lazy"></figure>
<p>这样看来这个函数也实现了模型实例化功能，并对渲染性能有一个很大的提升，尤其是对于显卡性能稳定的机器（官方论坛有人做过测试）FPS可以达到25Hz以上，人眼感觉不出卡顿，画面流畅，并且性能差不多提升了3倍。</p>
<p>但是想一下，它们都是无论是静态物体树、路灯，还是动态物体的飞机、船舶，刨除它们的几何结构一致，它们的材质/纹理也是完全相同的。也符合了Unity /UE 中批处理的前提是使用同一个材质。但想想，航班系统，显示来自各家公司的飞机，它们可能来自同一种机型，但是每家航空公司的标志不同，全部贴在飞机上，纹理就各不相同了，如果不能使用批处理，那性能压力一下就上来了。再想想建筑房屋，在城市中不可能所有的房屋长一个样子，因此也无法以一个模型代替所有，但是房屋大多都是对称的，对于同一栋房屋或者同一个小区的房屋，它们总有纹理相同或相似的地方，或许可以把相同的纹理提取出来渲染到把多个房屋骨架上，也就是纹理合并。经查询， Unity 本身是支持纹理合并的，但是到Cesium 上，它对于纹理合并完全不支持。甚至说它的实例化也是不完美的，当我给飞机设定路线让它们全部移动后，这些飞机诡异地抖动了，官方至今没有给出解答。</p>
<p>好吧，综上，虽然纹理合并很有前景，但对于入门的我来说过于困难，如果有大佬感兴趣的话，可以在这一方面开拓，我没有翻阅到相关论文，在论坛虽然看到了类似想法的帖子，但是始终没有后续。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Cesium 介绍]]></title>
        <id>https://shangxiaoyun.github.io/post/cesium-jie-shao/</id>
        <link href="https://shangxiaoyun.github.io/post/cesium-jie-shao/">
        </link>
        <updated>2022-08-02T06:46:25.000Z</updated>
        <content type="html"><![CDATA[<p>地理信息系统（Geographic Information System, GIS）是20世纪60年代中期发展起来的新技术，是对地球表面空间信息进行采集、处理、存储、查询、分析和显示的计算机系统，是以计算机图形图像处理、数据库技术、测绘遥感技术及现代数学研究方法为基础，集空间数据和属性数据于一体的综合空间信息系统。</p>
<p>​        而三维地理信息系统（3D Geographic Information System, 3D GIS）又是 GIS 中的一个重要分支，它以立体构造技术给用户展现地理空间现象，能够表达空间对象间的三维空间关系，并对对象进行三维空间分析和操作。该应用已经深入到社会的各行各业中，如城市管理、工业仿真、基础建设等。</p>
<p>​        随着 Web 技术和 WebGL 技术的发展，三维 WebGIS 的研发逐渐走向成熟，国内外涌现出大量虚拟地球平台，国外有 Google Earth 、 ArcGIS 、Cesium 等，国内有 SuperMap 、EV-Globe 等。其中 CesiumJS 项目由 AGI 公司于 2011 年创建，是一个使用 js 编写的基于 WebGL 的地图引擎，它支持 3D, 2D, 2.5D 形式的地图展示，支持显示海量三维模型数据、影像数据、地形数据、矢量数据等。</p>
<p>​        说到 Cesium 的三维模型可视化，不得不提到 AGI 公司于 2015 年 6 月定制的一套用于流式传输海量三维地理空间数据集的开放规范 3dtiles，关于规范的描述可以上 github Cesium 团队的3d-tiles 仓库学习，网上也有很多pdf 的翻译版，但是具体参数的含义还是需要拿三维数据在 Cesium 中可视化，进入源码中调试，才能有更深的体会。本人也由于对 transform 和 gltfUpAxis 理解不深遇到过问题。回到这个规范，它包含多种类型的三维地理空间内容，如倾斜摄影模型、BIM 建筑模型、人工模型、海量点云、矢量数据等，将这些多源异构三维空间数据转化为三维瓦片（3dtiles）格式，就可以高效地进行数据可视化与数据分析。换句话说，只要按照 3dtiles 规范组织三维数据，哪怕它们的采集方式、数据类型不同，都可以可视化，这种开源开放且稳定灵活的数据格式受到许多研究者的推崇，去年11月，Cesium 团队提出了3dtiles next，即1.1版本，这个版本扩展了许多新功能，但当时许多功能还未完全实现，只是将思想呈现在草案中。</p>
<p>​       在 3dtiles next 中，提出了“隐式切片”（Implicit Tiling）的概念，它将瓦片的空间范围和空间索引方式“隐去”，即不显式地记录在瓦片对象中，而这种隐含的空间分割方法和索引方式，则是默认数据生产者和运行时知道的。我们可以理解为空间分割和瓦片索引方法全部都固定了，也就是说与二维地图、三维地形类似，可以针对全球划分网格、层级、经度，具体可以用 level /x / y.b3dm 来命名瓦片。这样的好处可想而知：（1） 能有效地减少 tileset.json 索引文件的体积，并提高了空间索引的效率，寻找、遍历瓦片的速度更快，射线计算、随机访问、空间查询也更快。（2）由于瓦片按照统一标准分割好，那不同版本的数据块可以很方便迭代替换，而不用担心数据块格式不同、范围有交集，还需要对模型进行切割或压平等复杂操作来实现目的。其实统一标准很多人都想做，但一直没有相关进展，就我去年研究的情况，3D Tiles 1.1 的数据生产工具仍然未实现，Cesium 团队也没有公开处理后可供实验的数据，甚至源码中支持的内容还不完整，在许多讨论中，也有大佬提出了许多需要处理的瓶颈，因此我对可视化效率优化的工作还是针对 1.0 版本进行。但是我们可以期待 Cesium 迎来又一次高峰。</p>
<p>​        说了这么多，我们来看看最后三维倾斜模型在 Cesium 呈现的效果是什么样的，这里我选取处理的香港三维倾斜模型来展示。</p>
<figure data-type="image" tabindex="1"><img src="https://shangxiaoyun.github.io/post-images/1660235123003.png" alt="" loading="lazy"></figure>
<p>​        上面一张俯视图，滚动鼠标可以做到画面缩放，同时带动相机视角远离或靠近模型。还可以将键盘Ctrl键和鼠标左键结合将相机视角拉平。下面用实验中长沙岳麓区的一小片数据来展示另外的视角画面。</p>
<figure data-type="image" tabindex="2"><img src="https://shangxiaoyun.github.io/post-images/1660235131531.png" alt="" loading="lazy"></figure>
<p>​        上面说到的三种展示地图的形式：3D, 2D, 2.5D，点击画面右上角的镂空网格球就可以切换。我展示的都是3D形式，可以通过滚轮缩小画面变换成球，也可以由其他形式转成 3D。2D是平面不多赘述，2.5D 也成为哥伦布视图，在 2D 的基础上有倾斜状态。</p>
<p>​         看到了展示的效果，很多人会疑问有啥用？主要还是为了展示，但可以和城市建设、模拟沙盘、灾害分析、应急测绘…挂钩，毕竟采集的三维模型自带地理信息。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[js继承的7种方式]]></title>
        <id>https://shangxiaoyun.github.io/post/js-ji-cheng-de-6-chong-fang-shi/</id>
        <link href="https://shangxiaoyun.github.io/post/js-ji-cheng-de-6-chong-fang-shi/">
        </link>
        <updated>2022-07-26T09:28:40.000Z</updated>
        <content type="html"><![CDATA[<p>参考文章：https://www.cnblogs.com/wrhbk/p/14477637.html<br>
https://blog.csdn.net/zhishiqu/article/details/108484245<br>
参考视频：https://www.bilibili.com/video/BV1YY4y1W7Uj/?spm_id_from=333.788&amp;vd_source=1abeefe13381c97e3a10c86d239b6aa4</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[项目优化]]></title>
        <id>https://shangxiaoyun.github.io/post/xiang-mu-you-hua-and-shang-xian/</id>
        <link href="https://shangxiaoyun.github.io/post/xiang-mu-you-hua-and-shang-xian/">
        </link>
        <updated>2022-07-23T19:04:41.000Z</updated>
        <content type="html"><![CDATA[<h2 id="项目优化策略"><strong>项目优化策略</strong></h2>
<p>可以从以下几个方向优化：</p>
<p>生成打包报告、第三方库启用CDN、Element-UI 组件按需加载、路由懒加载、图片压缩、Gzip 压缩、首页内容定制等。</p>
<h3 id="生成打包报告"><strong>生成打包报告</strong></h3>
<p>便于直观发现项目存在的问题，由于项目使用 vue-cli2 ，此处通过可视化面板（vue ui）查看报告。</p>
<h3 id="通过externals加载外部cdn资源"><strong>通过externals加载外部CDN资源</strong></h3>
<p>默认情况下，通过 import 语法导入的第三方依赖包，最终会被打包合并在同一个文件中，从而导致打包成功后，单文件体积过大的问题。为了解决该问题，可以通过 webpack 的 externals 节点，来配置并加载外部的 CDN 资源。凡是声明在 externals 中的第三方依赖包，都不会被打包。</p>
<p>css开源库：<a href="https://cdnjs.com/">cdnjs - The #1 free and open source CDN built to make life easier for developers</a></p>
<p>js开源库：<a href="https://www.jsdelivr.com/">jsDelivr - A free, fast, and reliable CDN for open source</a></p>
<p>首先，在 webpack.prod.conf.js 中的添加代码段：</p>
<pre><code>externals: {
    'vue': 'Vue',
    // 'vue-router': 'VueRouter',
    'axios': 'axios',
    'vue-lazyload':'VueLazyload',
    lodash:'_',
    echarts:'echarts',
    nprogress:'NProgress',
    'vue-quill-editor':'VueQuillEditor',
    'element-ui': 'ELEMENT'
}
</code></pre>
<p>然后在 index.html 中引入相关资源，资源版本参照 package.json 中的版本。</p>
<pre><code class="language-html"> &lt;!-- 富文本编辑器样式表 --&gt;
    &lt;link rel=&quot;stylesheet&quot; href=&quot;https://cdnjs.cloudflare.com/ajax/libs/quill/1.3.7/quill.core.css&quot;&gt;
    &lt;link rel=&quot;stylesheet&quot; href=&quot;https://cdnjs.cloudflare.com/ajax/libs/quill/1.3.7/quill.snow.css&quot;&gt;
    &lt;link rel=&quot;stylesheet&quot; href=&quot;https://cdnjs.cloudflare.com/ajax/libs/quill/1.3.7/quill.bubble.css&quot;&gt;
    &lt;!-- nprogress 进度条样式 --&gt;
    &lt;link rel=&quot;stylesheet&quot; href=&quot;https://cdnjs.cloudflare.com/ajax/libs/nprogress/0.2.0/nprogress.css&quot;&gt;
    &lt;link rel=&quot;stylesheet&quot; href=&quot;https://cdnjs.cloudflare.com/ajax/libs/element-ui/2.15.6/theme-chalk/index.min.css&quot;&gt;
    &lt;!-- element-ui 样式表 --&gt;
    &lt;link rel=&quot;stylesheet&quot; href=&quot;https://cdnjs.cloudflare.com/ajax/libs/element-ui/2.15.6/theme-chalk/index.min.css&quot;&gt;

    &lt;!-- js 文件 --&gt;
    &lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue@2.5.2/dist/vue.min.js&quot;&gt;&lt;/script&gt;
    &lt;!-- &lt;script src=&quot;https://cdnjs.cloudflare.com/ajax/libs/vue-router/2.5.2/vue-router.min.js&quot;&gt;&lt;/script&gt; --&gt;
    &lt;script src=&quot;https://cdn.jsdelivr.net/npm/axios@0.24.0/dist/axios.min.js&quot;&gt;&lt;/script&gt;
    &lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue-lazyload@1.3.3/vue-lazyload.min.js&quot;&gt;&lt;/script&gt;
    &lt;script src=&quot;https://cdn.jsdelivr.net/npm/lodash@4.17.21/lodash.min.js&quot;&gt;&lt;/script&gt;
    &lt;script src=&quot;https://cdnjs.cloudflare.com/ajax/libs/echarts/5.3.0/echarts.min.js&quot;&gt;&lt;/script&gt;
    &lt;script src=&quot;https://cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.min.js&quot;&gt;&lt;/script&gt;
    &lt;script src=&quot;https://cdnjs.cloudflare.com/ajax/libs/element-ui/2.15.6/index.min.js&quot;&gt;&lt;/script&gt;
    &lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue-quill-editor@3.0.6/dist/vue-quill-editor.min.js&quot;&gt;&lt;/script&gt;
</code></pre>
<p>main.js 中要注释 element-ui 的导入和使用，注释富文本编辑器和进度条的样式导入。</p>
<p>打包后 vender.js 文件体积显著减小。</p>
<h3 id="路由懒加载"><strong>路由懒加载</strong></h3>
<p>当打包构建项目时，JS包会变得很大，影响页面加载。因此把不同路由对应的组件分割成不同的代码块，然后当路由被访问的时候才加载对应组件，更加高效。其中，webpackChunkName  可以把不同的路由打包到一个 js 文件中，相当于路由分组。</p>
<pre><code class="language-js">const Login = () =&gt; import(/*webpackChunckName:&quot;Login_Home_Welcome&quot;*/'../components/Login.vue')
const Home = () =&gt; import(/*webpackChunckName:&quot;Login_Home_Welcome&quot;*/'../components/Home.vue')
const Welcome = () =&gt; import(/*webpackChunckName:&quot;Login_Home_Welcome&quot;*/'../components/Welcome.vue')
</code></pre>
<p>打包后，会形成多个 js 文件。</p>
<h3 id="图片压缩"><strong>图片压缩</strong></h3>
<p>使用 webpack 打包工具一定少不了一些好用的转换器（loaders）。其中，用于压缩图片的 loader 叫 image-webpack-loader。</p>
<p>在 webpack.base.conf.js 中设置：</p>
<pre><code class="language-js">{
    test: /\.(png|jpe?g|gif|svg)(\?.*)?$/,
    use:[
        //图片压缩
        {
            loader: 'image-webpack-loader',
            options: {
                disable: process.env.NODE_ENV === 'development', // 开发环境下禁止压缩
                bypassOnDebug: true,
                gifsicle: {
                    interlaced: false
                }
            }
        }
    ]
}
</code></pre>
<p>但是测试后上述设置对动态图片gif无效。</p>
<h3 id="gzip-压缩"><strong>Gzip 压缩</strong></h3>
<p>Gzip 压缩使用到 CompressionWebpackPlugin 插件（文本资源压缩插件）。</p>
<pre><code class="language-js">if (config.build.productionGzip) {
  const CompressionWebpackPlugin = require('compression-webpack-plugin')
  webpackConfig.plugins.push(
    new CompressionWebpackPlugin({
      asset: '[path].gz[query]',   // 会被替换的原始资源
      algorithm: 'gzip',
      //所有匹配该正则的资源都会被处理。默认值是全部资源。
      test: new RegExp(
        '\\.(' +
        config.build.productionGzipExtensions.join('|') +
        ')$'
      ),
      threshold: 10240, //只有大小大于该值的资源会被处理。单位是 bytes。默认值是 0。
      minRatio: 0.8  //只有压缩率小于这个值的资源才会被处理。默认值是 0.8。
    })
  )
}
</code></pre>
<h3 id="压缩代码"><strong>压缩代码</strong></h3>
<p>ExtractTextPlugin  用于将 css , less 打包成一个公共的文件的插件，这个公共的文件是 styles.css。OptimizeCssAssetsWebpackPlugin  压缩输出的 css 文件。UglifyJSPlugin 插件压缩代码（丑化后已无法阅读）。</p>
<pre><code class="language-js">new ExtractTextPlugin({
    filename: utils.assetsPath('css/[name].[contenthash].css'),
    allChunks: true
}),
new OptimizeCSSPlugin({
    cssProcessorOptions: config.build.productionSourceMap ? {safe: true, map: {inline: false}}: {safe: true}
}),
new UglifyJsPlugin({
    uglifyOptions: {
        compress: {
        	warnings: false
        }
    },
    sourceMap: config.build.productionSourceMap,
    parallel: true
})
</code></pre>
<p>OptimizeCssAssetsWebpackPlugin  还可以参考：<a href="https://blog.csdn.net/u012961419/article/details/107094111">(18条消息) webpack二刷之五、生产环境优化（5.提取压缩CSS）_皮蛋很白的博客-CSDN博客_optimization.minimizer</a></p>
<h3 id="上述打包结果"><strong>上述打包结果</strong></h3>
<figure data-type="image" tabindex="1"><img src="https://shangxiaoyun.github.io/post-images/1658603151637.png" alt="" loading="lazy"></figure>
<p>vendor.js 第三方库组件打包文件体积明显减小。jpg 图片压缩成功，但 gif 动态图没有压缩。（问题遗留）</p>
<h2 id="创建-web-服务器"><strong>创建 web 服务器</strong></h2>
<ol>
<li>
<p>初始化package.json     <code>npm init -y</code></p>
</li>
<li>
<p>安装依赖项  <code>cnpm install express -S</code></p>
</li>
<li>
<p>将 vue_shop 中打包生成的 dist 目录，复制到 vue_shop_server 文件夹中</p>
</li>
<li>
<p>新建app.js 入口文件。</p>
<pre><code class="language-js">const express = require('express')

// 创建 web 服务器
const app = express()

// 托管静态资源
app.use(express.static('./dist'))

// 启动 web 服务器
app.listen(80, () =&gt; {
  console.log('web server running at http://127.0.0.1');
})
</code></pre>
</li>
</ol>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[事件的防抖和节流]]></title>
        <id>https://shangxiaoyun.github.io/post/shi-jian-de-fang-dou-he-jie-liu/</id>
        <link href="https://shangxiaoyun.github.io/post/shi-jian-de-fang-dou-he-jie-liu/">
        </link>
        <updated>2022-07-23T17:25:39.000Z</updated>
        <content type="html"><![CDATA[<h2 id="节流"><strong>节流</strong></h2>
<p>节流的核心思想: 如果在定时器的时间范围内再次触发，则不予理睬，等当前定时器完成，才能启动<strong>下一个定时器任务</strong>。这就好比公交车，10 分钟一趟，无论车上乘客多少，到点才发车。<strong>节流可以连续触发</strong>。</p>
<p>代码如下:</p>
<pre><code>function throttle(fn, interval) {
  let flag = true;
  return funtion(...args) {
    let context = this;
    if (!flag) return;
    flag = false;
    setTimeout(() =&gt; {
      fn.apply(context, args);
      flag = true;
    }, interval);
  };
};
</code></pre>
<p>写成下面的方式也是表达一样的意思:</p>
<pre><code>const throttle = function(fn, interval) {
  let last = 0;
  return function (...args) {
    let context = this;
    let now = +new Date();
    // 还没到时间
    if(now - last &lt; interval) return;
    last = now;
    fn.apply(this, args)
  }
}
</code></pre>
<h2 id="防抖"><strong>防抖</strong></h2>
<p>核心思想: 每次事件触发则删除原来的定时器，建立新的定时器。你反复触发功能，那么只认最后一次，从最后一次触发开始计时。</p>
<pre><code>function debounce(fn, delay) {
  let timer = null;
  return function (...args) {
    let context = this;
    if(timer) clearTimeout(timer);
    timer = setTimeout(function() {
      fn.apply(context, args);
    }, delay);
  }
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[订单管理&数据统计]]></title>
        <id>https://shangxiaoyun.github.io/post/ding-dan-guan-li-andshu-ju-tong-ji/</id>
        <link href="https://shangxiaoyun.github.io/post/ding-dan-guan-li-andshu-ju-tong-ji/">
        </link>
        <updated>2022-07-23T10:00:25.000Z</updated>
        <content type="html"><![CDATA[<h3 id="订单列表可视化"><strong>订单列表可视化</strong></h3>
<ul>
<li>
<p>搜索框：由于后台没有做模糊匹配，因此前端来完成。</p>
<pre><code class="language-jsx">this.orderlist = this.orderAll.filter(item =&gt; {
  return item.order_number.match(info)
})
</code></pre>
</li>
<li>
<p>修改地址对话框的省市区/县的级联选择器：将数据由外部 city_data2017_element.js 导入。</p>
</li>
<li>
<p>展开订单详情，由于goods_origin_price 、goodsPic 和  goodsName 是异步请求获得，因此可视化时 goodslist 中并没这些属性，这里使用深拷贝，将处理后、拥有上述属性的arr 对 goodslist 重新赋值。</p>
<pre><code class="language-jsx">let goods_price_sum ,goods_origin_price = 0
let goodsName ,goodsPic= ''
let arr = _.cloneDeep(this.goodslist)
arr.forEach(async item =&gt; {
    goods_price_sum = item.goods_number * item.goods_price
    Object.assign(item,{goods_price_sum:goods_price_sum})
    const {data:res} = await this.$http.get(`goods/${item.goods_id}`)
    if(res.meta.status !== 200) return this.$message.error('获取商品信息失败！')
    goodsName = res.data.goods_name 
    Object.assign(item,{goodsName:goodsName})
    goods_origin_price = res.data.goods_price
    Object.assign(item,{goods_origin_price:goods_origin_price})
    goodsPic = res.data.pics[0].pics_sma_url
    Object.assign(item,{goodsPic:goodsPic})
}) 

setTimeout(() =&gt; {
    this.goodslist = arr;
    console.log(this.goodslist);
},500)
</code></pre>
</li>
</ul>
<h3 id="数据统计"><strong>数据统计</strong></h3>
<ul>
<li>echarts 使用
<ul>
<li>导入 echarts</li>
<li>为 echarts准备一个具备大小（宽高）的 DOM</li>
<li>在 mounted() 生命函数中，基于准备好的 DOM ，初始化 echarts 实例</li>
<li>准备数据和配置项</li>
<li>展示数据</li>
</ul>
</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[商品管理]]></title>
        <id>https://shangxiaoyun.github.io/post/shang-pin-guan-li/</id>
        <link href="https://shangxiaoyun.github.io/post/shang-pin-guan-li/">
        </link>
        <updated>2022-07-23T09:48:46.000Z</updated>
        <content type="html"><![CDATA[<h2 id="商品列表"><strong>商品列表</strong></h2>
<ul>
<li>
<p>添加商品。其中在商品基本信息有下拉商品分类菜单，因此还是需要调用 this.getCateList() 函数。</p>
<ul>
<li>
<p>使用编程式导航跳转到新的页面   <code>this.$router.push(’/goods/add’)</code></p>
</li>
<li>
<p><strong>富文本编辑器   vue-quill-editor</strong></p>
</li>
<li>
<p>上传图片这里由于没有使用 axios 发起 ajax 请求，因此及时显示图片，也是无效的，这是因为 token 无效。在上传每一张图片时，手动为它指定一个 headers 请求头，在请求头中包含一个字段属性 Authorization，保存 token 值，即为其提供 token 验证。</p>
<pre><code class="language-jsx">headerObj: {
  Authorization: window.sessionStorage.getItem('token')
}
</code></pre>
</li>
<li>
<p>这里一个问题是 预览不了图片。handlePreview() 预处理函数中处理 previewPath ，把本地图片地址换成后台图片地址。</p>
<pre><code class="language-jsx">this.previewPath = file.response.data.url.replace(
	'http://120.78.137.246', 'https://lianghj.top'
)
</code></pre>
</li>
<li>
<p>添加商品时 goods_cat 商品分类需要以字符串的形式上传，而在级联选择器中是以数组的形式存在，因此需要用 join() 函数，但是不能在 this.addForm 上直接修改。因此采用<strong>深拷贝 cloneDeep。</strong></p>
<pre><code class="language-js">import _ from 'lodash'
const form = _.cloneDeep(this.addForm) //全新的对象
form.goods_cat = form.goods_cat.join(',')
</code></pre>
</li>
</ul>
</li>
<li>
<p>编辑商品信息</p>
<ul>
<li>商品分类通过下拉菜单选择，但是看不见原始分类，因此考虑用 Tag 标签可视化出来（这里后端接口有一个错误：如果只设置到二级分类，那么三级分类会被上一次的三级分类代替），因此我们规定所有商品都有三级分类，添加商品时设置。</li>
<li>尝试把根据 id 获取商品信息和商品分类提出来，但是都出错了，主要是异步请求的问题。</li>
</ul>
</li>
</ul>
<h2 id="商品分类"><strong>商品分类</strong></h2>
<p>主要显示和编辑商品分类。这里也使用到 this.getCateList() 函数。</p>
<ul>
<li>显示使用树形表格，columns 是表格各列的配置。type 为 template 时，对应的是作用域插槽。</li>
</ul>
<h2 id="分类参数"><strong>分类参数</strong></h2>
<p>主要对不同的商品分类添加静态属性和动态属性。选择商品分类中级联选择框中又是全部商品分类，需要调用 this.getCateList() 函数。甚至下拉菜单选择框和面包屑导航相似，在多个组件中使用，可以一起导出使用。</p>
<ul>
<li>
<p>添加动态参数/静态属性的对话框共用一个，通过 activeName （many/only）判断具体是哪一个，使用计算属性来判断。</p>
</li>
<li>
<p>当点击 tag 时，标签变为输入框，且输入框获得焦点。这是需要使用 <code>$nextTick</code> ，它的作用是当页面上的元素被重新渲染之后，才会执行回调函数，这样在回调函数中才能拿到原生 DOM 对象。</p>
<pre><code class="language-jsx">this.$nextTick(_ =&gt; {
  this.$refs.saveTagInput.$refs.input.focus()
})
</code></pre>
</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[权限列表]]></title>
        <id>https://shangxiaoyun.github.io/post/quan-xian-lie-biao/</id>
        <link href="https://shangxiaoyun.github.io/post/quan-xian-lie-biao/">
        </link>
        <updated>2022-07-23T09:06:17.000Z</updated>
        <content type="html"><![CDATA[<h2 id="权限管理"><strong>权限管理</strong></h2>
<p>权限管理业务分析：</p>
<p>通过权限管理模块控制不同的用户可以进行哪些操作，具体可以通过角色的方式进行控制，即每个用户分配特定的角色，角色包括不同的功能权限。</p>
<figure data-type="image" tabindex="1"><img src="https://shangxiaoyun.github.io/post-images/1658567200989.png" alt="" loading="lazy"></figure>
<h2 id="角色列表"><strong>角色列表</strong></h2>
<p><strong>难点1</strong>：使用 v-for 循环渲染角色的权限（作用域插槽）</p>
<p><strong>难点2</strong>：每次删除一个权限时，将返回的 data 赋值给 role.children ，这里的 role 是 scope.row。而不应该重新执行 getRoleList() 函数，否则列表就会重新刷新渲染一次。展开栏也会合上。<br>
<img src="https://shangxiaoyun.github.io/post-images/1658567222052.png" alt="" loading="lazy"></p>
<p><strong>难点3</strong>：改进，当某个二级菜单下已经没有三级菜单时，对应的二级菜单也删除。当某个一级菜单下已经没有二级菜单时，一级菜单也随之删除。</p>
<p><strong>难点4</strong>：tree结构</p>
<ul>
<li>递归获取三级节点的 id 放到 defKeys 数组中，通过 Tree 组件的 :default-checked-keys 属性来表示选中的项。</li>
<li>通过 Tree 组件 ref 对象的 getCheckedKeys() 和 getHalfCheckedKeys() 方法得到全选和半选中的id数组，最后通过 join() 拼接，得到的信息作为一项参数发送分配权限请求。</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[用户列表]]></title>
        <id>https://shangxiaoyun.github.io/post/yong-hu-lie-biao/</id>
        <link href="https://shangxiaoyun.github.io/post/yong-hu-lie-biao/">
        </link>
        <updated>2022-07-23T08:53:15.000Z</updated>
        <content type="html"><![CDATA[<h3 id="插槽形式的自定义列的渲染"><strong>插槽形式的自定义列的渲染</strong></h3>
<p>操作列包含修改、删除、分配角色三个功能。这些操作都需要获取当前用户id，因此需要使用作用域插槽获取当前行的内容（scope.row）。</p>
<h3 id="添加用户对话框中渲染一个表单"><strong>添加用户对话框中渲染一个表单</strong></h3>
<ul>
<li>在 Form 组件中，每一个表单域由一个 Form-Item 组件构成，表单域中可以放置各种类型的表单控件，包括 Input、Select、Checkbox、Radio、Switch、DatePicker、TimePicker。</li>
<li>:model数据绑定，要将数据绑定到一张表单addForm，:rules绑定表单的验证规则，添加表单的验证规则对象addFormRules{}，ref给el-form组件起了一个引用名称：addFormRef。</li>
<li>el-form中prop对应验证规则的属性。Form 组件提供了表单验证的功能，只需要通过 rules 属性传入约定的验证规则，并将 Form-Item 的 prop 属性设置为需校验的字段名即可。</li>
</ul>
<h3 id="实现自定义规则"><strong>实现自定义规则</strong></h3>
<ul>
<li>
<p>一个箭头函数代表一个自定义规则。箭头函数有三个参数：rule,value,callback。rule代表验证规则，value代表需要验证的值，callback为回调函数。只要验证通过了，可以直接在箭头函数中调用callback回调函数，表示验证通过。如果验证失败，则需要返回一个error。</p>
</li>
<li>
<p>在data()中通过 var 定义一个变量来定义校验规则，它的值指向一个箭头函数，箭头函数中包含具体的校验规则（正则表达式），通过test方法来校验是否合法，然后在具体的规则中通过validator指定自定义校验规则，通过trigger指定触发校验的时机。</p>
<pre><code class="language-js">//验证手机号的规则
var checkMobile = (rule, value, callback) =&gt; {
    //验证手机号的正则表达式
    const regMobile = /^1[3-9][0-9]{9}$/
    if (regMobile.test(value)) {
        //合法的手机号
        return callback()
    }
    return callback(new Error('请输入合法的手机号'))
}

addFormRules: {
    mobile: [
        { required: true, message: '请输入手机号', trigger: 'blur' },
        { validator: checkMobile, trigger: 'blur' }
    ]
}
</code></pre>
</li>
</ul>
<h3 id="添加用户表单的重置功能"><strong>添加用户表单的重置功能</strong></h3>
<p>给对话框添加一个对话框关闭事件，关闭事件中对用户表单进行重置。通过<code>this.$refs</code>拿到addFormRef（表单引用），然后调用重置方法 <code>this.$refs.addFormRef.resetFields()</code>。</p>
<h3 id="实现添加用户功能"><strong>实现添加用户功能</strong></h3>
<p>点击按钮，添加新用户，首先需要进行预验证操作。通过<code>this.$refs.addFormRef</code>拿到表单引用，然后调用validate方法进行校验。函数内部提供一个箭头函数，来接受校验结果valid。</p>
<p>当预校验通过后可以发起一个添加用户的网络请求。</p>
<pre><code class="language-js">this.$refs.addFormRef.validate(async value =&gt; {
    if (!value) return
    //可以发起添加用户的网络请求
   	...
})
</code></pre>
<h3 id="实现删除用户的功能"><strong>实现删除用户的功能</strong></h3>
<p>点击删除按钮时不能立刻删除数据，因为有可能用户误操作，并不是真的想删除数据，所以此处应该有<strong>弹框提醒</strong>。此处用到弹框组件：<strong>MessageBox</strong>。</p>
<p>调用 <code>$confirm</code> 方法即可打开消息提示，它模拟了系统的  confirm 。Message Box 组件也拥有极高的定制性，我们可以传入options 作为第三个参数，它是一个字面量对象。type 表明消息类型，可以为 success，error ，info 和 warning，无效的设置将会被忽略。注意，第二个参数 title 必须定义为 String 类型，如果是 Object，会被理解为 options。在这里我们用了 Promise 来处理后续响应。通过调用<code>this.$confirm</code>来弹出消息提示框。</p>
<pre><code class="language-js">async removeUserById(id) {
    //弹框询问用户是否删除数据
    const confirmResult = await this.$confirm(
        '此操作将永久删除该用户, 是否继续?',
        '提示',
        {
            confirmButtonText: '确定',
            cancelButtonText: '取消',
            type: 'warning'
        }
    ).catch(err =&gt; err)
    //如果用户确认删除，则返回值为字符串 confirm
    //如果用户取消删除，则返回值为字符串 cancel
    if (confirmResult !== 'confirm') {
        return this.$message.info('已取消删除')
    }
   	// 删除用户...
}
</code></pre>
]]></content>
    </entry>
</feed>